<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Carte ATEMAX ‚Äì AutoPlay + Synth√®se OK</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <!-- Flatpickr -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">

  <style>
    html, body, #map { height: 100%; margin: 0; font-family: sans-serif; }
    #new-signal {
      position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
      background: white; padding: 6px 12px; border-radius: 8px;
      font-weight: bold; font-size: 14px; z-index: 1001;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2); text-decoration: none; color: black;
    }

    /* HUD vent (fl√®che + vitesse) */
    #windHud {
      position: absolute; top: 10px; right: 10px; z-index: 1002; /* au-dessus du bouton */
      display: flex; flex-direction: column; align-items: center; pointer-events: none;
    }
    .wind-icon svg { width:60px; height:60px; opacity:0.6; }
    .wind-speed{
      background:rgba(255,255,255,.85);
      padding:3px 8px;border-radius:6px;box-shadow:0 1px 2px rgba(0,0,0,.25);
      font-weight:bold;text-align:center;margin-top:4px; font-size:11px;
    }

    #controls {
      max-width: 92vw;
      position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
      background: white; padding: 6px 10px; border-radius: 10px;
      font-size: 13px; z-index: 1000; box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      display: flex; flex-wrap: wrap; align-items: center; justify-content: center; gap: 8px;
    }
    label, select, input[type="checkbox"], input[type="range"], span { font-size: 13px; }
    input[type="range"] { width: 140px; transition: opacity 0.3s ease; }
    input[type="range"].disabled { opacity: 0.3; pointer-events: none; }
    .hidden { display: none !important; }
    .flatpickr-calendar { z-index: 3000 !important; }

    /* Player */
    #playerControls { display:flex; align-items:center; gap:6px; }
    #btnPlayPause{
      width:32px;height:32px;border:none;border-radius:50%;cursor:pointer;
      box-shadow:0 1px 3px rgba(0,0,0,.3);background:#E74C3C;color:#fff;font-size:16px;line-height:32px;padding:0;
      display:flex;align-items:center;justify-content:center;font-weight:bold;
    }
    #speedSelect{ border:1px solid #ccc; border-radius:6px; padding:2px 4px; }

    @media (max-width: 600px) {
      #controls { flex-wrap: wrap; overflow-x: auto; justify-content: flex-start; }
      input[type="range"] { width: 100px; }
    }

    /* Canvas particules */
    canvas.particle-canvas {
      position:absolute; top:0; left:0; pointer-events:none; z-index: 500; /* sous les contr√¥les */
    }
  </style>
</head>
<body>
<a href="index.html" id="new-signal">‚ûï Faire un nouveau signalement</a>
<div id="windHud"></div>
<div id="map"></div>

<div id="controls">
  <div style="display:flex; align-items:center;">
    <span style="margin-right:4px;">üìÖ</span>
    <select id="preset">
      <option value="today">Aujourd‚Äôhui</option>
      <option value="yesterday">Hier</option>
      <option value="last7">7 derniers jours</option>
      <option value="last30">30 derniers jours</option>
      <option value="custom">P√©riode personnalis√©e</option>
      <option value="single">Choisir une date</option>
    </select>
  </div>
  <input id="customRange" type="text" class="hidden" placeholder="Date d√©but - fin" readonly />
  <input id="singleDate" type="text" class="hidden" placeholder="Choisir une date" readonly />

  <!-- Par d√©faut d√©coch√© pour afficher la synth√®se -->
  <label><input type="checkbox" id="modeDynamic" /> √âvolution dynamique</label>

  <div style="display:flex; align-items:center; gap:6px;">
    <span style="margin-right:4px;">‚è±Ô∏è</span>
    <input type="range" id="slider" min="0" max="0" value="0" class="disabled" disabled />
  </div>
  <span id="sliderLabel"></span>

  <!-- Player auto play/pause -->
  <div id="playerControls" class="hidden">
    <button id="btnPlayPause" title="Lecture/Pause">‚ñ∂</button>
    <select id="speedSelect" title="Vitesse">
      <option value="1000">x1</option>
      <option value="500">x2</option>
      <option value="250">x4</option>
    </select>
    <label style="display:flex; align-items:center; gap:3px;">
      <input type="checkbox" id="loop" checked /> R√©p√©ter
    </label>
  </div>
</div>

<!-- Libs -->
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/fr.js"></script>

<script>
// ==================== Helpers ====================
function parseFrDate(str){
  const [d,m,rest]=str.split('/');
  if(!rest) return new Date(str);
  const [y,time='00:00:00']=rest.split(' ');
  const [hh,mm,ss]=time.split(':');
  return new Date(+y,+m-1,+d,+(hh||0),+(mm||0),+(ss||0));
}
function avg(arr){return arr.length?arr.reduce((a,b)=>a+b,0)/arr.length:NaN;}
function avgDir(degArr){
  if(!degArr.length) return NaN;
  let x=0,y=0;degArr.forEach(d=>{const r=d*Math.PI/180;x+=Math.cos(r);y+=Math.sin(r);});
  return (Math.atan2(y,x)*180/Math.PI+360)%360;
}
function numVal(v){const n=parseFloat(String(v).replace(',','.'));return isNaN(n)?NaN:n;}
function windDirectionLabel(deg) {
  if (isNaN(deg)) return '‚Äî';

  const dirs = [
    { a:   0, t: 'du nord' },
    { a:  45, t: 'du nord‚Äëest' },
    { a:  90, t: 'de l‚Äôest' },
    { a: 135, t: 'du sud‚Äëest' },
    { a: 180, t: 'du sud' },
    { a: 225, t: 'du sud‚Äëouest' },
    { a: 270, t: 'de l‚Äôouest' },
    { a: 315, t: 'du nord‚Äëouest' }
  ];

  return dirs.reduce((p, c) => Math.abs(c.a - deg) < Math.abs(p.a - deg) ? c : p).t;
}


// ==================== Map ====================
const map = L.map('map').setView([44.214, 0.606], 14);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 18, attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

const usineIcon = L.divIcon({ html: '<div style="font-size:48px;">üè≠</div>', iconSize: [48,48], className: 'usine-marker' });
L.marker([44.212805, 0.597916], { icon: usineIcon }).addTo(map).bindPopup("Usine d'incin√©ration ATEMAX");

const getColor = i => ["#FADADD","#F5B7B1","#EC7063","#E74C3C","#CB4335","#943126","#78281F","#641E16","#512E2E"][Math.min(9, Math.max(0, i-1))];

// ---------------- Vent -----------------
const USINE = [44.212805, 0.597916];
const windHudEl = document.getElementById('windHud');

function makeWindIconHTML(dirDeg, speedKmh){
  const svg = `<svg viewBox='0 0 100 100' style='transform: rotate(${(dirDeg + 180) % 360}deg);'>

    <path d='M50 4 L72 58 L56 52 L56 96 L44 96 L44 52 L28 58 Z' fill='black' fill-opacity='0.6' stroke='white' stroke-width='4' stroke-linejoin='round'/>
  </svg>`;
  const html = `<div class='wind-icon'>${svg}<div class='wind-speed'>${isNaN(speedKmh)?'?':speedKmh+' km/h'}</div></div>`;
  return html;
}
function updateWindMarker(dir, speed){
  if(!windHudEl) return;
  windHudEl.innerHTML = makeWindIconHTML(isNaN(dir)?0:dir, speed);
}



// ==================== M√©t√©o live si aucun signalement ====================
const fallbackLat = 44.212805;
const fallbackLon = 0.597916;
const API_KEY = "5e7795e19d6fbcb80542a3ea152b1d1e"; // ‚úÖ m√™me cl√© que le formulaire

async function fetchLiveWind(){
  try {
    const url = `https://api.openweathermap.org/data/2.5/weather?lat=${fallbackLat}&lon=${fallbackLon}&appid=${API_KEY}&units=metric`;
    const res = await fetch(url);
    const json = await res.json();
    const deg = json.wind?.deg;
    const speed = json.wind?.speed ? Math.round(json.wind.speed * 3.6) : NaN;
    if (!isNaN(deg)) updateWindMarker(deg, speed);
  } catch(e){
    console.warn("Erreur r√©cup√©ration vent live :", e);
  }
}




// ==================== State ====================
let allData = [], grouped = [], labels = [], windMeta = [];
const slider = document.getElementById('slider');
const labelTxt = document.getElementById('sliderLabel');
const modeDynamic = document.getElementById('modeDynamic');
const preset = document.getElementById('preset');
const customInput = document.getElementById('customRange');
const singleInput = document.getElementById('singleDate');

const btnPlayPause = document.getElementById('btnPlayPause');
const speedSelect = document.getElementById('speedSelect');
const loopCheckbox = document.getElementById('loop');
const playerControls = document.getElementById('playerControls');

let isPlaying = false;
let playTimer = null;
let frameDelay = 1000; // ms

// ==================== Map update ====================
const updateMap = (points) => {
  if (window.layer) map.removeLayer(window.layer);
  window.layer = L.layerGroup(points.map(p =>
    L.circle([p.lat, p.lon], {
      color: getColor(p.intensite),
      fillColor: getColor(p.intensite),
      fillOpacity: 0.6,
      radius: 60
    }).bindPopup(`
  <strong>${p.type}</strong><br>
  Intensit√© : ${p.intensite}/10<br>
  ${p.commentaire}<br>
  ${p.dateStr}<br>
  Vent ${isNaN(p.windDir) ? 'inconnu' : `du ${windDirectionLabel(p.windDir)} (${Math.round(p.windDir)}¬∞)`} √† ${isNaN(p.windSpeed) ? '‚Äì' : `${p.windSpeed} km/h`}
`)

  )).addTo(map);
};

// ==================== Wind calc ====================
function windFromArray(arr){
  const dirs = arr.map(p=>p.windDir).filter(v=>!isNaN(v));
  const speeds = arr.map(p=>p.windSpeed).filter(v=>!isNaN(v));
  return { dir: dirs.length?avgDir(dirs):NaN, speed: speeds.length?Math.round(avg(speeds)):NaN };
}

// ==================== Grouping ====================
const groupBy = (data, interval) => {
  const g = {};
  data.forEach(row => {
    const d = new Date(row.dateObj);
    if (interval === '10min') { d.setSeconds(0,0); d.setMinutes(Math.floor(d.getMinutes()/10)*10); }
    else if (interval === 'hour') { d.setMinutes(0,0,0); }
    else if (interval === 'day') { d.setHours(0,0,0,0); }
    const key = d.toISOString();
    (g[key] ||= []).push(row);
    });
  const keys = Object.keys(g).sort();
  labels = keys.map(k => new Date(k).toLocaleString('fr-FR'));

  windMeta = keys.map(k => windFromArray(g[k]));
  return keys.map(k => g[k]);
};

// ==================== PARTICULES ‚ÄúFUM√âE‚Äù KAKI (subtile, largeur x2) ====================
let pCanvas, pCtx, particles = [], segs = [];
let pAnimId = null;
const PART_TOTAL_MAX = 450; // densit√© inchang√©e

function initParticlesCanvas(){
  pCanvas = document.createElement('canvas');
  pCanvas.className = 'particle-canvas';
  map.getContainer().appendChild(pCanvas); // fix√© au container, pas au pane
  pCtx = pCanvas.getContext('2d');

  function resize(){
    const size = map.getSize();
    pCanvas.width  = size.x;
    pCanvas.height = size.y;
  }
  resize();
  map.on('resize', resize);
}

function buildSegments(points){
  segs = points.map(p=>({
    sLL: L.latLng(USINE[0], USINE[1]),
    eLL: L.latLng(p.lat, p.lon)
  }));
}

function spawnParticle(p){
  if(!segs.length) return;
  const idx = Math.floor(Math.random()*segs.length);
  p.seg   = idx;
  p.t     = Math.random()*0.1;              // d√©part proche usine
  p.size  = 12 + Math.random()*32;           // √ó2 par rapport √† 6‚Äì16
  p.alpha = 0.03 + Math.random()*0.07;       // tr√®s transparent
  p.speed = 0.0018 + Math.random()*0.0025;
  p.phi   = Math.random()*Math.PI*2;
  p.jit   = 0.10 + Math.random()*0.22;
}

function particlesClear(){
  particles = [];
  segs = [];
  if(pCtx && pCanvas) pCtx.clearRect(0,0,pCanvas.width,pCanvas.height);
  if(pAnimId){ cancelAnimationFrame(pAnimId); pAnimId = null; }
}

function setParticlesPoints(points){
  if(!pCtx) initParticlesCanvas();
  if(!points || !points.length){
    particlesClear();
    return;
  }

  buildSegments(points);

  const target = Math.min(PART_TOTAL_MAX, segs.length * 40);
  if(particles.length < target){
    for(let i = particles.length; i < target; i++){
      const p = {};
      spawnParticle(p);
      particles.push(p);
    }
  } else if(particles.length > target){
    particles.length = target;
  }

  if(!pAnimId) animateParticles();
}

function animateParticles(){
  pAnimId = requestAnimationFrame(animateParticles);
  if(!pCtx) return;

  pCtx.clearRect(0,0,pCanvas.width,pCanvas.height);
  const base = {r:107,g:142,b:35}; // kaki

  particles.forEach(p=>{
    const s = segs[p.seg];
    if(!s){ spawnParticle(p); return; }

    const sPx = map.latLngToContainerPoint(s.sLL);
    const ePx = map.latLngToContainerPoint(s.eLL);
    const vx = ePx.x - sPx.x;
    const vy = ePx.y - sPx.y;
    const len = Math.sqrt(vx*vx + vy*vy) || 1;

    const xBase = sPx.x + vx * p.t;
    const yBase = sPx.y + vy * p.t;

    const nx = -vy / len;
    const ny =  vx / len;
    const jitter = Math.sin(p.t*8 + p.phi) * p.jit * len * 0.02;
    const x = xBase + nx * jitter;
    const y = yBase + ny * jitter;

    const g = pCtx.createRadialGradient(x, y, 0, x, y, p.size);
    const a = p.alpha;
    g.addColorStop(0.0, `rgba(${base.r},${base.g},${base.b},${a})`);
    g.addColorStop(0.4, `rgba(${base.r},${base.g},${base.b},${a*0.35})`);
    g.addColorStop(1.0, `rgba(${base.r},${base.g},${base.b},0)`);

    pCtx.fillStyle = g;
    pCtx.beginPath();
    pCtx.arc(x, y, p.size, 0, Math.PI*2);
    pCtx.fill();

    p.t += p.speed;
    if(p.t > 1){ spawnParticle(p); }
  });
}

// ==================== Frame setter ====================
function setFrame(idx){
  idx = Math.max(0, Math.min(idx, grouped.length-1));
  slider.value = idx;
  updateMap(grouped[idx] || []);
  labelTxt.innerText = labels[idx] || '';
  const wm = windMeta[idx] || {dir:NaN, speed:NaN};
  if (isNaN(wm.dir)) fetchLiveWind();
else updateWindMarker(wm.dir, wm.speed);


  // Particules pour cette tranche
  setParticlesPoints(grouped[idx] || []);
}

// ==================== Synthesis view ====================
function showSynthesis(){
  const flat = grouped.flat();
  updateMap(flat);
  labelTxt.innerText = '';
  const wm = windFromArray(flat);
  updateWindMarker(isNaN(wm.dir)?0:wm.dir, wm.speed);

  setParticlesPoints(flat);
}

// ==================== Refresh (filter + regroup) ====================
const refresh = (mode) => {
  let gtype = 'day';
  const today = new Date();

  if (mode === 'today' || mode === 'yesterday' || mode === 'single') gtype = '10min';
  else if (mode === 'last7')  gtype = 'hour';
  else if (mode === 'last30') gtype = 'day';
  else if (mode === 'custom') {
    const sel = fpRange.selectedDates;
    const diff = (sel[1] - sel[0]) / 86400000;
    gtype = diff <= 1 ? '10min' : diff <= 7 ? 'hour' : 'day';
  }

  const filtered = allData.filter(d => {
    const date = d.dateObj;
    if (mode === 'today')     return date.toDateString() === today.toDateString();
    if (mode === 'yesterday'){ const y = new Date(today); y.setDate(y.getDate()-1); return date.toDateString() === y.toDateString(); }
    if (mode === 'last7')     { const d7 = new Date(today); d7.setDate(d7.getDate()-7);  return date >= d7; }
    if (mode === 'last30')    { const d30 = new Date(today); d30.setDate(d30.getDate()-30); return date >= d30; }
    if (mode === 'single')    { const sel = fpSingle.selectedDates[0]; return sel && date.toDateString() === sel.toDateString(); }
    if (mode === 'custom')    { const [d1,d2] = fpRange.selectedDates; return d1 && d2 && date >= d1 && date <= d2; }
    return true;
  });

  grouped = groupBy(filtered, gtype);

  slider.max = Math.max(0, grouped.length - 1);
  slider.value = slider.max;

  const canSlide = grouped.length > 1 && modeDynamic.checked;
  slider.disabled = !canSlide;
  slider.classList.toggle('disabled', !canSlide);
  playerControls.classList.toggle('hidden', !canSlide);

  if (modeDynamic.checked && canSlide) {
    setFrame(slider.value);
    play();
  } else {
    pause();
    showSynthesis();
  }
};

// ==================== Slider & Mode ====================
modeDynamic.onchange = () => {
  const canSlide = modeDynamic.checked && grouped.length > 1;
  slider.disabled = !canSlide;
  slider.classList.toggle('disabled', !canSlide);
  playerControls.classList.toggle('hidden', !canSlide);

  if (!modeDynamic.checked) {
    pause();
    showSynthesis();
  } else {
    slider.max = Math.max(0, grouped.length - 1);
    if (+slider.value > +slider.max) slider.value = slider.max;
    setFrame(+slider.value || 0);
    play();
  }
};

slider.oninput = () => setFrame(+slider.value);

// ==================== Player ====================
function play(){
  if(isPlaying) return;
  if(grouped.length <= 1){ return; }
  isPlaying = true;
  btnPlayPause.textContent = '‚ùö‚ùö';
  playTimer = setInterval(()=>{
    let i = +slider.value + 1;
    if(i > +slider.max){
      if(loopCheckbox.checked){ i = 0; }
      else { pause(); return; }
    }
    setFrame(i);
  }, frameDelay);
}
function pause(){
  isPlaying = false;
  btnPlayPause.textContent = '‚ñ∂';
  if(playTimer) clearInterval(playTimer);
  playTimer = null;
}
btnPlayPause.onclick = ()=>{ isPlaying ? pause() : play(); };
speedSelect.onchange = e => {
  frameDelay = +e.target.value;
  if(isPlaying){ pause(); play(); }
};

// ==================== Flatpickr ====================
flatpickr.setDefaults({ locale:"fr" });
const fpRange = flatpickr("#customRange", {
  mode: "range", dateFormat: "d/m/Y",
  onClose: () => refresh("custom")
});
const fpSingle = flatpickr("#singleDate", {
  dateFormat: "d/m/Y",
  onClose: () => refresh("single")
});

preset.onchange = e => {
  const val = e.target.value;
  const showCustom = val === 'custom';
  const showSingle = val === 'single';
  customInput.classList.toggle('hidden', !showCustom);
  singleInput.classList.toggle('hidden', !showSingle);
  if (showCustom)      setTimeout(()=>fpRange.open(),0);
  else if (showSingle) setTimeout(()=>fpSingle.open(),0);
  else                 refresh(val);
};

// ==================== Load data (Google Sheets) ====================
fetch("https://opensheet.elk.sh/1z6YXiX0MKEwrZ0rnjgj4mfFSUSk6wRh6-kRK9JCSIzc/Feuille%201")
  .then(res=>res.json())
  .then(rows=>{
    allData = rows.map(r=>{
      const dateStr = r["Date/heure"]; 
      const dateObj = parseFrDate(dateStr);
      return {
        lat: numVal(r["Latitude"]),
        lon: numVal(r["Longitude"]),
        intensite: parseInt(r["Intensit√©"],10),
        type: r["Type d‚Äôodeur"],
        commentaire: r["Commentaire"],
        dateStr, dateObj,
        windSpeed: numVal(r["Vent (km/h)"]),
        windDir:   numVal(r["Direction vent (¬∞)"])
      };
    }).filter(d=>!isNaN(d.lat)&&!isNaN(d.lon)&&d.dateObj instanceof Date && !isNaN(d.dateObj));

    refresh('today');
  });
</script>
</body>
</html>
